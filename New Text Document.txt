"""
 Print elements of a linked list on console
 head input could be None as well for empty list
 Node is defined as
 
 class Node(object):
 
   def __init__(self, data=None, next_node=None):
       self.data = data
       self.next = next_node
 
 
"""
def print_list(head):
    if head == None:
        print
    else:
        while head:
            print head.data
            head = head.next

//insert node at first of list
/*
  Insert Node at the beginning of a linked list 
  head pointer input could be NULL as well for empty list
  Node is defined as 
  class Node {
     int data;
     Node next;
  }
*/
// This is a "method-only" submission. 
// You only need to complete this method. 

Node Insert(Node head,int x) {
    if(head == null){
        Node newNode = new Node();
        newNode.data = x;
        head = newNode;
        return head;
    } else{
    Node newNode = new Node();
    newNode.data = x;
    newNode.next = head;
    head = newNode;
    return head;
    }
}

//insert node at end of list
/*
  Insert Node at the end of a linked list 
  head pointer input could be NULL as well for empty list
  Node is defined as 
  class Node {
     int data;
     Node next;
  }
*/
Node Insert(Node head,int data) {
// This is a "method-only" submission. 
// You only need to complete this method. 
  if(head == null){
      Node newNode = new Node();
      newNode.data = data;
      head = newNode;
      return head;
  }else{
      Node newNode = new Node();
      newNode = head;
      Node n = new Node();
      while(newNode.next != null){
          newNode = newNode.next;
      }
      n.data = data;
      newNode.next = n;
      return head;
  }
}

//insert node at nth position
/*
  Insert Node at a given position in a linked list 
  head can be NULL 
  First element in the linked list is at position 0
  Node is defined as 
  class Node {
     int data;
     Node next;
  }
*/
    

Node InsertNth(Node head, int data, int position) {
   // This is a "method-only" submission. 
    // You only need to complete this method. 
    Node newNode = new Node();
    newNode.data = data;
    if(position == 0){
        newNode.next = head;
        head = newNode;
        return head;
    }
    if(position != 0 && head == null){
        return head;
    }else if(head == null && position == 0){
        head = newNode;
        return head;
    }
    Node current = head;
    Node previous = null;

    for(int i = 0; i < position; i++) {
        previous = current;
        current = current.next;
        if(current == null)
            break;
    }

    newNode.next = current;
    previous.next = newNode;
    return head;
    
}


//delete node at nth position
/*
  Insert Node at the end of a linked list 
  head pointer input could be NULL as well for empty list
  Node is defined as 
  class Node {
     int data;
     Node next;
  }
*/
    // This is a "method-only" submission. 
    // You only need to complete this method. 

Node Delete(Node head, int position) {
  // Complete this method
   if(head == null)
       return head;
    Node current = head;
    if(position == 0){
        head = current.next;
        return head;
    }
    for(int i = 0; current != null && i < position-1; i++)
        current = current.next;
    if(current == null || current.next == null)
        return head;
    Node next = current.next.next;
    current.next = next;
    return head;
    
}

//reverse a list
/*
  Insert Node at the end of a linked list 
  head pointer input could be NULL as well for empty list
  Node is defined as 
  class Node {
     int data;
     Node next;
  }
*/
    // This is a "method-only" submission. 
    // You only need to complete this method. 

void ReversePrint(Node head) {
  // This is a "method-only" submission. 
  // You only need to complete this method. 
/*
  Insert Node at the end of a linked list 
  head pointer input could be NULL as well for empty list
  Node is defined as 
  class Node {
     int data;
     Node next;
  }*/
  // This is a "method-only" submission. 
  // You only need to complete this method. 
    if(head == null)
        return;
    if(head.next != null) { 
        ReversePrint(head.next);  
    }
    System.out.println(head.data);
  

}

//reverse a list
/*
  Reverse a linked list and return pointer to the head
  The input list will have at least one element  
  Node is defined as  
  class Node {
     int data;
     Node next;
  }
*/
    // This is a "method-only" submission. 
    // You only need to complete this method. 
Node Reverse(Node head) {
    if(head.next == null)
        return head;
    else{
        Node previous = null;
        Node temp = head;
        while (temp != null) {
            Node next = temp.next;
            temp.next = previous;
            previous = temp;
            temp = next;
        }
        head = previous;
      }
    return head;
 }

//compare 2 list
/*
  Compare two linked lists A and B
  Return 1 if they are identical and 0 if they are not. 
  Node is defined as 
  class Node {
     int data;
     Node next;
  }
*/
int CompareLists(Node headA, Node headB) {
    // This is a "method-only" submission. 
    // You only need to complete this method 
    int flag = 0;
    Node n1 = headA, n2 = headB;
    while(n1 != null && n2 != null){
        if(n1.data != n2.data)
            //flag = 1;
            //break;  
            return 0;
            
        
        n1 = n1.next;
        n2 = n2.next;
        
    }
    if(n1 == null && n2 == null)
        return 1;
    else
        return 0;
}

//merging 2 sorted link list

/*
  Merge two linked lists 
  head pointer input could be NULL as well for empty list
  Node is defined as 
  class Node {
     int data;
     Node next;
  }
*/

Node MergeLists(Node headA, Node headB) {
     // This is a "method-only" submission. 
     // You only need to complete this method 
    if(headA == null)
        return headB;
    else if(headB == null)
        return headA;
    
        Node n = null;
    if(headA.data < headB.data){
        n = headA;
        n.next = MergeLists(headA.next, headB);
    }else{
        n = headB;
        n.next = MergeLists(headA, headB.next);
    }
    return n;
}


